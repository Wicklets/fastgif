<script src="a.out.js"></script>
<script src="bower_components/gifuct-js/dist/gifuct-js.min.js"></script>
<script type="module">

  const all = [];

async function run() {
  const resp = await window.fetch('large.gif');
  const arr = new Uint8Array(await resp.arrayBuffer());

  console.info('sending buffer', arr.length, arr);

  const alloc = Module._malloc(arr.length);
  Module.writeArrayToMemory(arr, alloc);

  const readBuffer = Module.cwrap('read_buffer', 'string', ['number', 'number']);
  const play = Module.cwrap('play', 'string');

  readBuffer(alloc, arr.length);

  console.time('play');
  const s = play();
  console.timeEnd('play');
  console.info('response', s, 'frames', all.length);
  if (!all.length) {
    throw new Error('got no frames');
  }

  console.time('utf8');
  const decoder = new TextDecoder('utf8');
  all.forEach((frame) => {
    frame.s = decoder.decode(frame.bytes);
  });
  console.timeEnd('utf8');


  // what about a JS library?
  console.time('gifuct');
  const gif = new GIF(arr);
  const frames = gif.decompressFrames(true);
  console.timeEnd('gifuct');



  let i = 0;
  let prevMicros = 0;
  while (true) {
    if (i === 0) {
      prevMicros = 0;
    }

    const frame = all[i];
    i = (i + 1) % all.length;

    display.textContent = frame.s;
    const delay = (frame.micros - prevMicros) / 1000;
    prevMicros = frame.micros;

    await new Promise((resolve) => window.setTimeout(resolve, delay));
  }

}

window.onframe = (buf, len, micros) => {
  const bytes = new Uint8Array(len);
  bytes.set(Module.HEAP8.slice(buf, buf + len));
  all.push({bytes, micros});
};

function ready() {
  run().catch((err) => console.error(err));
}

Module['onRuntimeInitialized'] = ready;

</script>
<body>

<pre id="display"></pre>

</body>